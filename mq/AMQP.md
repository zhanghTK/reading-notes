服务模型：投递服务模型，而非 CS 服务模型。
  在程序角度：当程序连接到 RabbitMQ 时必须决定自己是发送者还是接受者
  在 AMQP 角度：AMQP 是生产者还是消费者
  
宏观
消息发送：由生产者创建，包括标签和内容

路由：根据消息标签把消息发给接收方，路由过程中标签没有被传递；消息发后即忘

消息接受：从订阅队列接收消息，无法感知发送方

信道：建立在 TCP 连接内的虚拟连接，具有唯一 ID，避免 TCP 开销



微观
消息路由：交换器、队列、绑定

生产者把消息发布到交换器，绑定决定消息如何从交换器路由到特定队列

订阅队列中的消息：
  - basic.consume：
  - basic.get
  
消息投递：
  - 当队列拥有多个消费者时，每个消息只发送给一个订阅消费者
  - 投递过程：
    - 消息到达队列
    - MQ 将消息发送给订阅的消费者
    - 消费者确认接收到消息：basic.ack
    - MQ 删除队列中的消息
  - MQ 未收到消费者确认将不再向该消费者投递消息  
  - 拒绝消息
    - 连接断开
    - basic.reject
      - true：MQ 将消息发送给其他订阅消费者
      - false：MQ 将消息从队列移除，并加入 dead letter 队列
- 队列
  - 创建:
    - 生产者
    - 消费者：统一信道上订阅了另一个队列的话，将无法再声明队列，必须先取消订阅并将信道设置为传输模式
    - 由谁负责创建：生产消费者都尝试创建
    - 创建命令：queue.declare
  - 订阅&绑定：根据名称
  - 参数：
    - exclusive：私有队列
    - auto-delete：当没有消费者订阅队列时，队列自动移除
  - 特点：
    - 消息暂存，等待被消费
    - 负载均衡
    - MQ 中的终点
    
交换器 & 绑定
路由键：决定 MQ 将消息从交换器投递到哪个队列，绑定队列到交换器
交换器：
  - 有多种类型，每种类型对应不同路由算法，使用 exchange.declare 命令设置
  - 类型
    - direct：如果路由键匹配。消息被投递到对应队列。
      - 服务器必须实现默认交换器（名字为空）
      - 声明一个队列时会自动绑定到默认交换器
      - 消息发送：$channel->basic_publish($msg, '', 'queue-name');
        - $msg：消息
        - ''：指定默认交换器
        - ''：路由器键
      - 可以多重绑定：一个交换器与多个队列使用相同的路由键绑定，类似广播
    - fanout：将收到的消息广播到绑定的队列，交换器接收的消息转发给绑定的所有队列
      - 不需要路由键
      - 需要提前将交换器和队列绑定，二者是多对多关系
    - topic：来自不同源头的消息能够到达同一个队列
      - 需要路由键
      - 需要提前绑定交换器和队列，绑定时用到路由键
      - 一个消息满足从交换器到同一个队列的多个匹配只投递一次
      - * 将 . 视为分隔符，# 将任意字符均视为关键字的匹配
    - headers：匹配 header 而非路由键，性能差，不使用
    
多租户模式
vhost：由 RabbitMQ 服务器创建的虚拟消息服务器（mini 版的 RabbitMQ），拥有单独的队列，交换器，绑定，权限
vhost 之间绝对隔离，优点：安全，便于移植
当在 vhost 集群上创建 vhost 时，整个集群都会创建该 vhost
创建：rabbitmqctl add_vhost [vhost_name]
删除：rabbitmqctl delete_vhost [vhost_name]
查看 rabbitmqctl list_vhosts

持久化
默认情况下：队列和交换器及里面的消息会随服务器重启删除
持久化的要求：
- 消息的投递模式设置为 2（持久）
- 发送到持久化的交换器
- 到达持久化的队列
持久化的影响：消息吞吐量极大下降（10倍都不少见），集群环境下工作的不好

事务
AMQP 事务：设置信道为事务模式，发送消息，提交；问题：性能，迫使生产者与 MQ 产生同步
RabbitMQ：发送方确认，信道设置成 confirm 模式，即可发送消息。信道为消息指派唯一ID，消息发服务端处理完成后**异步**发送一个确认给生产者
