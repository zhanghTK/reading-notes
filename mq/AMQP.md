服务模型：投递服务模型，而非 CS 服务模型。
  在程序角度：当程序连接到 RabbitMQ 时必须决定自己是发送者还是接受者
  在 AMQP 角度：AMQP 是生产者还是消费者
  
宏观
消息发送：由生产者创建，包括标签和内容

路由：根据消息标签把消息发给接收方，路由过程中标签没有被传递；消息发后即忘

消息接受：从订阅队列接收消息，无法感知发送方

信道：建立在 TCP 连接内的虚拟连接，具有唯一 ID，避免 TCP 开销



微观
消息路由：交换器、队列、绑定

生产者把消息发布到交换器，绑定决定消息如何从交换器路由到特定队列

订阅队列中的消息：
  - basic.consume：
  - basic.get
  
消息投递：
  - 当队列拥有多个消费者时，每个消息只发送给一个订阅消费者
  - 投递过程：
    - 消息到达队列
    - MQ 将消息发送给订阅的消费者
    - 消费者确认接收到消息：basic.ack
    - MQ 删除队列中的消息
  - MQ 未收到消费者确认将不再向该消费者投递消息  
  - 拒绝消息
    - 连接断开
    - basic.reject
      - true：MQ 将消息发送给其他订阅消费者
      - false：MQ 将消息从队列移除，并加入 dead letter 队列
- 队列
  - 创建:
    - 生产者
    - 消费者：统一信道上订阅了另一个队列的话，将无法再声明队列，必须先取消订阅并将信道设置为传输模式
    - 由谁负责创建：生产消费者都尝试创建
    - 创建命令：queue.declare
  - 订阅&绑定：根据名称
  - 参数：
    - exclusive：私有队列
    - auto-delete：当没有消费者订阅队列时，队列自动移除
  - 特点：
    - 消息暂存，等待被消费
    - 负载均衡
    - MQ 中的终点
    
交换器 & 绑定
路由键：决定 MQ 将消息从交换器投递到哪个队列，绑定队列到交换器
交换器：
  - 有多种类型，每种类型对应不同路由算法，使用 exchange.declare 命令设置
  - 类型
    - direct：如果路由键匹配。消息被投递到对应队列。
      - 服务器必须实现默认交换器（名字为空）
      - 声明一个队列时会自动绑定到默认交换器
      - 消息发送：$channel->basic_publish($msg, '', 'queue-name');
        - $msg：消息
        - ''：指定默认交换器
        - ''：路由器键
    - fanout：将收到的消息广播到绑定的队列，交换器接收的消息转发给绑定的所有队列
      - 不需要路由键
      - 需要提前将交换器和队列绑定，二者是多对多关系
    - topic：来自不同源头的消息能够到达同一个队列
      - 需要路由键
      - 需要提前绑定交换器和队列，绑定时用到路由键
      
    - headers：匹配 header 而非路由键，性能差，不使用
