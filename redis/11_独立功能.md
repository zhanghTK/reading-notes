## 发布 & 订阅

### 频道的订阅与退订

Redis 将所有的频道订阅关系保存在 redisServer 的 pubsub_channels 字典，key 为 频道名，值为订阅的客户端链表

- 订阅，SUBSCRIBE 实现：更新 pubsub_channels 字典

- 退订，UNSUBSCRIBE 实现：更新 pubsub_channels 字典

### 模式的订阅与退订

Redis 将所有的模式订阅关系保存在 redisServer 的 pubsub_patterns 链表，链表的节点定义：

typedef struct pubsubPattern {
    redisClient *client;
    robj *pattern;
}

- 订阅，SUBSCRIBE 实现：更新 pubsub_patterns 链表

- 退订，PUNSUBSCRIBE 实现：更新 pubsub_patterns 链表

### 发送消息

1. 将消息发送给频道订阅者：从 pubsub_channels 字典中查找对应频道的所有客户端链表，遍历链表发送消息

2. 将消息发送给模式订阅者：遍历 pubsub_patterns 链表，查找与频道匹配的模式并发送消息给对应客户端

### 查看订阅信息

PUBSUB：查看频道/模式的相关信息

1. PUBSUB CHANNELS [pattern]：查看服务器当前被订阅的[所有/匹配 pattern]频道，遍历 pubsub_channel 字典实现

2. PUBSUB NUMSUB [channel-1 channel-2 ... channel-n]：接受任意多个频道作为输入参数，返回这些批闹的订阅者数量，返回 pubsub_channel 字典对应频道的链表长度

3. PUBSUB NUMPAT：返回服务器当前被订阅模式的数量，返回 pubsub_patterns 链表的长度实现

## 事务

### 事务实现

1. 事务开始，MULTI：修改客户端状态 flags 属性完成
2. 命令入队

   ![命令入队](http://redisbook1e-gallery.readthedocs.io/en/latest/_images/graphviz-80409479fc5a22a90d467a2f7c356ff3de00d6f7.png)

   事务队列的定义在 redisClient 的 multiState mstate 中：
   
   typedef struct multiState {
       multiCmd *commands;  // 事务队列，FIFO
       int count;  // 已入队命令计数
   } multiState;
   
   其中 multiCmd 的定义：
   
   typedef struct multiCmd {
       robj *argv;  // 参数
       int argc;  // 参数个数
       struct redisCommand *cmd;  // 命令指针
   }

3. 执行事务，EXEC：遍历客户端的事务队列，执行队列中保存的所有命令，将执行结果全部返回客户端

### WATCH 命令

WATCH 是乐观锁，在事务执行前监视任意数量的键，并在事务执行时检查被监视的键，要求都没有被修改才可以执行

WATCH 监视的键保存在 redisDb 的 dict *watched_keys 字典中，键是数据库键，值是监视该键的所有客户端组成的链表

#### 监视机制触发，所有写操作执行后都会调用 multi.c/touchWatchKey 函数对 watched_keys 字典检查，当检查到键，开启对应客户端的 REDIS_DIRTY_CAS 标示，标记客户端的事务安全性已被破坏

#### 判断事务是否安全，检查客户端的 REDIS_DIRTY_CAS 是否打开

### 事务的 ACID

A（原子性）：Redis 并不支持事务回滚，要么完全不执行，要么完全执行（即使中间出错也会继续执行下去）
C（一致性）：通过检查保证
  1. 入队错误：命令不存在、命令格式不正确等，拒绝执行
  2. 执行错误：执行中发生错误，错误命令不会对数据库修改
  3. 服务器停机
     - 内存模式：重启后数据库为空
     - RDB 模式：根据 RDB 文件恢复
     - AOF 模式：根据 AOF 文件恢复
I（隔离性）：单线程执行事务，服务器不对执行中事务进行中断
D（持久性）：在事务最后加 SAVE 命令确保事务持久性（效率低，不推荐），否则由运行模式决定：
  - 内存模式：不具有持久性
  - RDB 模式：不具有持久性
  - AOF 模式 & appendfsync = always：具有持久性（当打开 no-appendfsync-on-rewrite 时不具有持久性）
  - AOF 模式 & appendfsync = everysec：不具有持久性
  - AOF 模式 & appendfsync = no，不具有持久性